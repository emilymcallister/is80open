const fetch = require('node-fetch');
const cheerio = require('cheerio');

async function fetchCaltransData() {
  try {
    const response = await fetch(
      'https://roads.dot.ca.gov/roadscell.php?roadnumber=80',
      {
        headers: {
          'User-Agent':
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.5',
        },
        timeout: 15000,
      }
    );

    if (!response.ok) {
      console.error('Caltrans returned status:', response.status);
      return null;
    }

    const html = await response.text();
    console.log('Fetched Caltrans HTML, length:', html.length);
    return html;
  } catch (error) {
    console.error('Error fetching Caltrans data:', error.message);
    return null;
  }
}

function parseStatus(html) {
  if (!html || html.length < 100) {
    return {
      status: 'unknown',
      details: ['Unable to fetch road conditions from Caltrans.'],
      debug: 'No HTML or HTML too short: ' + (html ? html.length : 0) + ' chars'
    };
  }

  const $ = cheerio.load(html);

  // Strategy 1: Look for all text content and find Route 80 in Northern CA
  const allText = $('body').text();
  console.log('Page text length:', allText.length);
  console.log('First 500 chars:', allText.substring(0, 500));

  // Strategy 2: Look at all table cells, divs, paragraphs for road info
  const allElements = [];
  $('td, div, p, span, pre, font, b, li').each(function () {
    const text = $(this).text().trim();
    if (text.length > 5 && text.length < 2000) {
      allElements.push(text);
    }
  });

  // Join everything and search for I-80 / Route 80 info
  const megaText = allElements.join('\n---\n');

  // Find chunks that mention Route 80
  const route80Chunks = allElements.filter(el => {
    const upper = el.toUpperCase();
    return (
      /\bROUTE\s*80\b/i.test(upper) ||
      /\bRT\.?\s*80\b/i.test(upper) ||
      /\bI[\s-]*80\b/i.test(upper) ||
      /\bSR[\s-]*80\b/i.test(upper) ||
      /\bINTERSTATE\s*80\b/i.test(upper)
    );
  });

  console.log('Found', route80Chunks.length, 'chunks mentioning Route 80');

  // Also search the entire page text for Northern California section
  const upperAll = allText.toUpperCase();

  // Try to find the Northern California section specifically
  let northernCalText = '';
  const ncIndex = upperAll.indexOf('NORTHERN CALIFORNIA');
  const sierraIndex = upperAll.indexOf('SIERRA');

  if (ncIndex !== -1) {
    // Get a big chunk after "Northern California"
    northernCalText = allText.substring(ncIndex, ncIndex + 10000);
    console.log('Found Northern California section at index', ncIndex);
  } else if (sierraIndex !== -1) {
    northernCalText = allText.substring(Math.max(0, sierraIndex - 500), sierraIndex + 5000);
    console.log('Found Sierra reference at index', sierraIndex);
  }

  // Combine all our sources of Route 80 info
  const allRoute80Text = [
    ...route80Chunks,
    northernCalText
  ].join('\n').toUpperCase();

  console.log('Combined Route 80 text length:', allRoute80Text.length);
  if (allRoute80Text.length > 0) {
    console.log('Route 80 text sample:', allRoute80Text.substring(0, 800));
  }

  // If we have literally no Route 80 text, try the full page
  const searchText = allRoute80Text.length > 50 ? allRoute80Text : upperAll;

  // Now analyze the text for conditions
  return analyzeConditions(searchText, allRoute80Text, megaText);
}

function analyzeConditions(searchText, route80Text, fullPageText) {
  const details = [];
  let isClosed = false;
  let hasRestrictions = false;
  let isExplicitlyOpen = false;

  // ============================================
  // CLOSURE DETECTION
  // ============================================
  const closureSignals = [
    { pattern: /CLOSED/g, weight: 3 },
    { pattern: /CLOSURE/g, weight: 3 },
    { pattern: /ROAD\s*CLOSED/g, weight: 5 },
    { pattern: /IS\s+CLOSED/g, weight: 5 },
    { pattern: /CLOSED\s+(?:FROM|AT|BETWEEN|NEAR|DUE|UNTIL)/g, weight: 5 },
    { pattern: /IMPASSABLE/g, weight: 4 },
    { pattern: /SHUT\s*DOWN/g, weight: 4 },
    { pattern: /NO\s+ESTIMATED\s+TIME\s+(?:OF\s+)?OPEN/g, weight: 5 },
    { pattern: /WILL\s+(?:BE\s+)?CLOSED/g, weight: 4 },
    { pattern: /REMAINS?\s+CLOSED/g, weight: 5 },
  ];

  // False positive closure patterns (things that say CLOSED but aren't full road closures)
  const closureFalsePositives = [
    /RAMP\s+(?:IS\s+)?CLOSED/i,
    /CLOSED\s+TO\s+OVERSIZ/i,
    /REST\s*AREA.*CLOSED/i,
    /CONNECTOR.*CLOSED/i,
    /WEIGH\s*STATION.*CLOSED/i,
    /PARK.*CLOSED/i,
    /PREVIOUSLY\s+CLOSED/i,
    /HAS\s+BEEN\s+RE-?\s*OPENED/i,
  ];

  let closureScore = 0;
  for (const signal of closureSignals) {
    const matches = searchText.match(signal.pattern);
    if (matches) {
      // Check each match isn't a false positive
      for (const match of matches) {
        const matchIndex = searchText.indexOf(match);
        const context = searchText.substring(
          Math.max(0, matchIndex - 80),
          Math.min(searchText.length, matchIndex + 120)
        );

        const isFalsePositive = closureFalsePositives.some(fp => fp.test(context));
        if (!isFalsePositive) {
          closureScore += signal.weight;
          details.push(context.trim().substring(0, 150));
        }
      }
    }
  }

  if (closureScore >= 3) {
    isClosed = true;
    console.log('CLOSURE detected, score:', closureScore);
  }

  // ============================================
  // RESTRICTION DETECTION (chains, controls, etc.)
  // ============================================
  const restrictionSignals = [
    { pattern: /\bR[\s-]*1\b/g, weight: 4, label: 'R1 Chain Control' },
    { pattern: /\bR[\s-]*2\b/g, weight: 4, label: 'R2 Chain Control' },
    { pattern: /\bR[\s-]*3\b/g, weight: 4, label: 'R3 Chain Control' },
    { pattern: /CHAIN\s*CONTROL/g, weight: 5, label: 'Chain Control' },
    { pattern: /CHAINS?\s+(?:ARE\s+)?REQUIRED/g, weight: 5, label: 'Chains Required' },
    { pattern: /CHAINS?\s+OR\s+SNOW\s*TIRES/g, weight: 5, label: 'Chains or Snow Tires' },
    { pattern: /TRACTION\s+DEVICES?\s+(?:ARE\s+)?REQUIRED/g, weight: 5, label: 'Traction Devices Required' },
    { pattern: /SNOW\s*TIRES?\s+REQUIRED/g, weight: 4, label: 'Snow Tires Required' },
    { pattern: /MUST\s+CARRY\s+CHAINS/g, weight: 5, label: 'Must Carry Chains' },
    { pattern: /CHAIN\s+REQUIREMENT/g, weight: 5, label: 'Chain Requirement' },
    { pattern: /ONE[\s-]*WAY\s+TRAFFIC/g, weight: 3, label: 'One-Way Traffic Control' },
    { pattern: /PILOT\s+CAR/g, weight: 3, label: 'Pilot Car' },
    { pattern: /CONVOY/g, weight: 3, label: 'Convoy' },
    { pattern: /ESCORT/g, weight: 2, label: 'Escort' },
    { pattern: /CONTROLLED\s+TRAFFIC/g, weight: 3, label: 'Controlled Traffic' },
    { pattern: /EXPECT\s+(?:MAJOR\s+)?DELAYS/g, weight: 2, label: 'Expect Delays' },
    { pattern: /HAZARDOUS\s+CONDITIONS/g, weight: 3, label: 'Hazardous Conditions' },
    { pattern: /WHITEOUT/g, weight: 3, label: 'Whiteout Conditions' },
    { pattern: /ZERO\s+VISIBILITY/g, weight: 3, label: 'Zero Visibility' },
    { pattern: /SPIN[\s-]*OUTS?/g, weight: 2, label: 'Spinouts' },
    { pattern: /JACK[\s-]*KNIFE/g, weight: 2, label: 'Jackknifed Vehicle' },
    { pattern: /HEAVY\s+SNOW/g, weight: 2, label: 'Heavy Snow' },
    { pattern: /REDUCED\s+(?:TO\s+)?(?:ONE|SINGLE)\s+LANE/g, weight: 3, label: 'Reduced to One Lane' },
  ];

  let restrictionScore = 0;
  const restrictionLabels = [];

  for (const signal of restrictionSignals) {
    const matches = searchText.match(signal.pattern);
    if (matches) {
      restrictionScore += signal.weight * matches.length;
      restrictionLabels.push(signal.label);
      console.log('Restriction signal:', signal.label, '- matches:', matches.length);
    }
  }

  if (restrictionScore >= 2) {
    hasRestrictions = true;
    console.log('RESTRICTIONS detected, score:', restrictionScore);
  }

  // ============================================
  // OPEN DETECTION
  // ============================================
  const openSignals = [
    /NO\s+RESTRICTIONS/i,
    /NO\s+TRAFFIC\s+RESTRICTIONS/i,
    /ALL\s+LANES?\s+OPEN/i,
    /OPEN\s+AND\s+CLEAR/i,
    /NO\s+DELAYS/i,
    /NORMAL\s+CONDITIONS/i,
    /IS\s+OPEN/i,
  ];

  for (const pattern of openSignals) {
    if (pattern.test(searchText)) {
      isExplicitlyOpen = true;
      console.log('OPEN signal detected:', pattern.toString());
    }
  }

  // ============================================
  // SMART DETERMINATION
  // ============================================

  // Closure overrides everything
  if (isClosed && closureScore >= 5) {
    return {
      status: 'closed',
      details: [...new Set(details)].slice(0, 5),
      restrictionLabels,
      scores: { closure: closureScore, restriction: restrictionScore },
    };
  }

  // If both closed and restriction signals, but closure is weak, call it restrictions
  if (isClosed && closureScore < 5 && hasRestrictions) {
    return {
      status: 'restrictions',
      details: [...new Set(details)].slice(0, 5),
      restrictionLabels,
      scores: { closure: closureScore, restriction: restrictionScore },
    };
  }

  // If closed with moderate confidence
  if (isClosed) {
    return {
      status: 'closed',
      details: [...new Set(details)].slice(0, 5),
      restrictionLabels,
      scores: { closure: closureScore, restriction: restrictionScore },
    };
  }

  // Restrictions
  if (hasRestrictions) {
    return {
      status: 'restrictions',
      details: [...new Set(details)].slice(0, 5),
      restrictionLabels,
      scores: { closure: closureScore, restriction: restrictionScore },
    };
  }

  // Explicitly open
  if (isExplicitlyOpen) {
    return {
      status: 'open',
      details: ['No restrictions reported on I-80'],
      restrictionLabels: [],
      scores: { closure: 0, restriction: 0 },
    };
  }

  // ============================================
  // FALLBACK: SMART TEXT ANALYSIS
  // ============================================
  // If we got here, our specific patterns didn't match.
  // Do a broader "vibe check" on the text.

  const concerningWords = [
    'SNOW', 'ICE', 'STORM', 'WIND', 'HAZARD', 'CAUTION',
    'SLOW', 'DELAY', 'BACKED UP', 'CONGESTION', 'INCIDENT',
    'ACCIDENT', 'CRASH', 'COLLISION', 'OVERTURNED', 'SLIDE',
    'AVALANCHE', 'ROCKFALL', 'FLOODING', 'FIRE'
  ];

  let concernScore = 0;
  for (const word of concerningWords) {
    const regex = new RegExp('\\b' + word + '\\b', 'gi');
    const matches = searchText.match(regex);
    if (matches) {
      concernScore += matches.length;
    }
  }

  console.log('Fallback concern score:', concernScore);

  // If there are several concerning words, probably restrictions
  if (concernScore >= 3) {
    return {
      status: 'restrictions',
      details: ['Weather or incident conditions detected on I-80'],
      restrictionLabels: ['General advisory'],
      scores: { closure: 0, restriction: 0, concern: concernScore },
    };
  }

  // If we truly found nothing, check if the page even had content
  if (searchText.length < 100) {
    return {
      status: 'unknown',
      details: ['Could not read Caltrans road conditions page.'],
      restrictionLabels: [],
      scores: { closure: 0, restriction: 0 },
      debug: 'Search text too short: ' + searchText.length
    };
  }

  // If page had content but no signals either way, assume open
  return {
    status: 'open',
    details: ['No restrictions or closures detected on I-80'],
    restrictionLabels: [],
    scores: { closure: 0, restriction: 0 },
  };
}

module.exports = async function handler(req, res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Cache-Control', 's-maxage=90, stale-while-revalidate=30');

  try {
    const html = await fetchCaltransData();
    const statusData = parseStatus(html);

    const now = new Date();
    const pacificTime = now.toLocaleString('en-US', {
      timeZone: 'America/Los_Angeles',
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      second: '2-digit',
      hour12: true,
    });

    console.log('Final status:', statusData.status);
    console.log('Details:', statusData.details);

    res.status(200).json({
      ...statusData,
      checkedAt: pacificTime,
      timestamp: now.toISOString(),
    });
  } catch (error) {
    console.error('Handler error:', error);
    res.status(500).json({
      status: 'unknown',
      details: ['Error checking road conditions: ' + error.message],
      checkedAt: new Date().toLocaleString('en-US', {
        timeZone: 'America/Los_Angeles',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
      }),
      error: error.message,
    });
  }
};
